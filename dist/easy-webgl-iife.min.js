var EW = (function (exports) {
  'use strict';

  exports.WARN_LEVEL = void 0;
  (function (WARN_LEVEL) {
      WARN_LEVEL[WARN_LEVEL["WARN"] = 1] = "WARN";
      WARN_LEVEL[WARN_LEVEL["DANGER"] = 2] = "DANGER";
      WARN_LEVEL[WARN_LEVEL["ERROR"] = 3] = "ERROR";
  })(exports.WARN_LEVEL || (exports.WARN_LEVEL = {}));
  var warn = function (err, level) {
      if (level === void 0) { level = 1; }
      if (level === 1) {
          console.error('warning:', err);
      }
      if (level === 2) {
          console.error('error:', err);
      }
      if (level === 3) {
          throw new Error(err);
      }
  };

  var toRgb = function (colorString) {
      if (colorString[0] !== '#' || colorString.length !== 7) {
          warn('color is not valid. example:#000000', 3);
      }
      else {
          var t = colorString.split('#');
          var rgb = [];
          for (var i = 0; i < 3; i++) {
              rgb.push(parseInt(t[1][i] + t[1][i + 1], 16));
          }
          return rgb;
      }
  };

  exports.isWebGl2 = true;
  var createContext = function (query) {
      var dom = document.querySelector(query);
      if (!dom) {
          warn('Dom is not available!');
          return;
      }
      var gl = dom.getContext('webgl2');
      if (!gl) {
          gl = dom.getContext('webgl');
          exports.isWebGl2 = false;
      }
      if (!gl) {
          warn('not support WebGL!', exports.WARN_LEVEL.ERROR);
      }
      return gl;
  };
  exports.ShaderType = void 0;
  (function (ShaderType) {
      ShaderType["VERTEX_SHADER"] = "vs";
      ShaderType["FRAGMENT_SHADER"] = "fs";
  })(exports.ShaderType || (exports.ShaderType = {}));
  var loadShader = function (gl, type, source) {
      var shader = type === 'vs'
          ? gl.createShader(gl.VERTEX_SHADER)
          : gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(shader, source);
      console.log(gl, type, source, shader);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          gl.deleteShader(shader);
          throw new Error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
      }
      return shader;
  };
  var createShaderProgram = function (gl, vsSource, fsSource) {
      var vertexShader = loadShader(gl, exports.ShaderType.VERTEX_SHADER, vsSource);
      var fragmentShader = loadShader(gl, exports.ShaderType.FRAGMENT_SHADER, fsSource);
      var shaderProgram = gl.createProgram();
      gl.attachShader(shaderProgram, vertexShader);
      gl.attachShader(shaderProgram, fragmentShader);
      gl.linkProgram(shaderProgram);
      if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          throw new Error('Unable to initialize the shader program: ' +
              gl.getProgramInfoLog(shaderProgram));
      }
      gl.useProgram(shaderProgram);
      return shaderProgram;
  };
  var initBuffers = function (gl, vertices) {
      var positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      return positionBuffer;
  };

  var setRectangle = function (gl, x, y, width, height) {
      var x1 = x;
      var x2 = x + width;
      var y1 = y;
      var y2 = y + height;
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          x1, y1,
          x2, y1,
          x1, y2,
          x1, y2,
          x2, x2,
          y1, y2,
      ]), gl.STATIC_DRAW);
  };

  var pointsVertexShader = function () {
      return "\n    attribute vec4 a_position;\n    void main() {\n      gl_Position = a_position;\n    }\n  ";
  };
  var pointsFragmentShader = function (r, g, b) {
      return "\n      void main(){\n        gl_FragColor = vec4(".concat(r, ", ").concat(g, ", ").concat(b, ", 1.0);\n      }\n  ");
  };

  var EwContext = (function () {
      function EwContext(query) {
          this.gl = null;
          this.program = null;
          this.strokeStyle = '';
          this.strokeRgb = [];
          this.init(query);
      }
      EwContext.prototype.beginPath = function () { };
      EwContext.prototype.closePath = function () { };
      EwContext.prototype.init = function (query) {
          this.gl = createContext(query);
      };
      EwContext.prototype.clearRect = function () {
          var gl = this.gl;
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.clearDepth(1.0);
      };
      EwContext.prototype.drawImage = function () { };
      EwContext.prototype.fillRect = function (x, y, width, height) { };
      EwContext.prototype.lineTo = function () {
      };
      EwContext.prototype.moveTo = function () { };
      EwContext.prototype.stroke = function () { };
      EwContext.prototype.strokeRect = function (x, y, width, height) { };
      return EwContext;
  }());

  exports.EwContext = EwContext;
  exports.createContext = createContext;
  exports.createShaderProgram = createShaderProgram;
  exports.initBuffers = initBuffers;
  exports.loadShader = loadShader;
  exports.pointsFragmentShader = pointsFragmentShader;
  exports.pointsVertexShader = pointsVertexShader;
  exports.setRectangle = setRectangle;
  exports.toRgb = toRgb;
  exports.warn = warn;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({});
