var WARN_LEVEL;
(function (WARN_LEVEL) {
    WARN_LEVEL[WARN_LEVEL["WARN"] = 1] = "WARN";
    WARN_LEVEL[WARN_LEVEL["DANGER"] = 2] = "DANGER";
    WARN_LEVEL[WARN_LEVEL["ERROR"] = 3] = "ERROR";
})(WARN_LEVEL || (WARN_LEVEL = {}));
const warn = (err, level = 1) => {
    if (level === 1) {
        console.error('warning:', err);
    }
    if (level === 2) {
        console.error('error:', err);
    }
    if (level === 3) {
        throw new Error(err);
    }
};

const toRgb = (colorString) => {
    if (colorString[0] !== '#' || colorString.length !== 7) {
        warn('color is not valid. example:#000000', 3);
    }
    else {
        const t = colorString.split('#');
        const rgb = [];
        for (let i = 0; i < 3; i++) {
            rgb.push(parseInt(t[1][i] + t[1][i + 1], 16));
        }
        return rgb;
    }
};

const canvasToWebglCoordinate = (x, y, canvasWidth, canvasHeight) => {
    return {
        x: (x / canvasWidth) * 2 - 1,
        y: -((y / canvasHeight) * 2 - 1),
    };
};

class Point {
    constructor(ix, iy, toWebGl = false, canvasWidth, canvasHeight) {
        this.x = 0;
        this.y = 0;
        if (toWebGl) {
            const { x, y } = canvasToWebglCoordinate(ix, iy, canvasWidth, canvasHeight);
            this.x = x;
            this.y = y;
        }
        else {
            this.x = ix;
            this.y = iy;
        }
    }
}

const offsetLine = (distance, startPoint, endPoint) => {
    const k = (endPoint.y - startPoint.y) / (endPoint.x - startPoint.x);
    const tx = Math.sqrt(Math.pow(distance, 2) / (1 + Math.pow(k, 2)));
    const ty = k * tx;
    return [
        new Point(startPoint.x - tx, startPoint.y + ty),
        new Point(endPoint.x - tx, endPoint.y + ty),
        new Point(startPoint.x + tx, startPoint.y - ty),
        new Point(endPoint.x + tx, endPoint.y - ty),
    ];
};

const loadImage = (url, callback) => {
    const img = document.createElement('img');
    img.setAttribute("crossOrigin", "anonymous");
    img.src = url;
    img.addEventListener('load', () => {
        callback(img);
    });
};

let isWebGl2 = true;
const createContext = (query) => {
    const dom = document.querySelector(query);
    if (!dom) {
        warn('Dom is not available!');
        return;
    }
    let gl = dom.getContext('webgl2');
    if (!gl) {
        gl = dom.getContext('webgl');
        isWebGl2 = false;
    }
    if (!gl) {
        warn('not support WebGL!', WARN_LEVEL.ERROR);
    }
    return { gl, dom };
};
var ShaderType;
(function (ShaderType) {
    ShaderType["VERTEX_SHADER"] = "vs";
    ShaderType["FRAGMENT_SHADER"] = "fs";
})(ShaderType || (ShaderType = {}));
const loadShader = (gl, type, source) => {
    const shader = type === 'vs'
        ? gl.createShader(gl.VERTEX_SHADER)
        : gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        gl.deleteShader(shader);
        throw new Error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
    }
    return shader;
};
const createShaderProgram = (gl, vsSource, fsSource) => {
    const vertexShader = loadShader(gl, ShaderType.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, ShaderType.FRAGMENT_SHADER, fsSource);
    const shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        throw new Error('Unable to initialize the shader program: ' +
            gl.getProgramInfoLog(shaderProgram));
    }
    gl.useProgram(shaderProgram);
    return shaderProgram;
};
const initBuffers = (gl, vertices) => {
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    return positionBuffer;
};
const injectAttribute2D = (gl, buffer, data) => {
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(data);
    gl.vertexAttribPointer(data, 2, gl.FLOAT, false, 0, 0);
};

class Vector2 {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }
    set(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
    }
    setX(x) {
        this.x = x;
        return this;
    }
    setY(y) {
        this.y = y;
        return this;
    }
    clone() {
        return new Vector2(this.x, this.y);
    }
    copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
    }
    add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
    }
    addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
    }
    addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
    }
    addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
    }
    sub(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
    }
    subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
    }
    subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
    }
    multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
    }
    multiplyScalar(s) {
        this.x *= s;
        this.y *= s;
        return this;
    }
    divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
    }
    divideScalar(s) {
        return this.multiplyScalar(1 / s);
    }
    applyMatrix3(m) {
        const x = this.x;
        const y = this.y;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6];
        this.y = e[1] * x + e[4] * y + e[7];
        return this;
    }
    min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
    }
    max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
    }
    clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
    }
    clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
    }
    clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
    }
    ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
    }
    round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
    roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
    }
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        return this.x * v.y - this.y * v.x;
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y;
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
        return this.divideScalar(this.length() || 1);
    }
    angle() {
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
    }
    distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
    }
    distanceToSquared(v) {
        const dx = this.x - v.x;
        const dy = this.y - v.y;
        return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    }
    setLength(length) {
        return this.normalize().multiplyScalar(length);
    }
    lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
    }
    lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
    }
    equals(v) {
        return v.x === this.x && v.y === this.y;
    }
    fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
    }
    toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
    }
    fromBufferAttribute(attribute, index, offset) {
        if (offset !== undefined) {
            console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
    }
    rotateAround(center, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const x = this.x - center.x;
        const y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
    }
    random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
    }
}
Vector2.prototype.isVector2 = true;

class Texture {
}

class Matrix4 extends Array {
    constructor() {
        super();
        for (let i = 0; i < 16; i++) {
            this[i] = 0;
        }
    }
    getOrigin(self) {
        if (self) {
            return this;
        }
        else {
            return new Matrix4();
        }
    }
    orthographic(left, right, bottom, top, near, far, self = true) {
        const r = this.getOrigin(self);
        r[0] = 2 / (right - left);
        r[1] = 0;
        r[2] = 0;
        r[3] = 0;
        r[4] = 0;
        r[5] = 2 / (top - bottom);
        r[6] = 0;
        r[7] = 0;
        r[8] = 0;
        r[9] = 0;
        r[10] = 2 / (near - far);
        r[11] = 0;
        r[12] = (left + right) / (left - right);
        r[13] = (bottom + top) / (bottom - top);
        r[14] = (near + far) / (near - far);
        r[15] = 1;
        return r;
    }
    translate(tx, ty, tz, self = true) {
        const r = this.getOrigin(self);
        r[12] = this[0] * tx + this[4] * ty + this[8] * tx + this[12];
        r[13] = this[1] * tx + this[5] * ty + this[9] * tx + this[13];
        r[14] = this[2] * tx + this[6] * ty + this[10] * tx + this[14];
        r[15] = this[3] * tx + this[7] * ty + this[11] * tx + this[15];
        if (!self) {
            for (let i = 0; i < 12; i++) {
                r[i] = this[i];
            }
        }
        return r;
    }
    scale(sx, sy, sz, self = true) {
        const r = this.getOrigin(self);
        r[0] = sx * this[0 * 4 + 0];
        r[1] = sx * this[0 * 4 + 1];
        r[2] = sx * this[0 * 4 + 2];
        r[3] = sx * this[0 * 4 + 3];
        r[4] = sy * this[1 * 4 + 0];
        r[5] = sy * this[1 * 4 + 1];
        r[6] = sy * this[1 * 4 + 2];
        r[7] = sy * this[1 * 4 + 3];
        r[8] = sz * this[2 * 4 + 0];
        r[9] = sz * this[2 * 4 + 1];
        r[10] = sz * this[2 * 4 + 2];
        r[11] = sz * this[2 * 4 + 3];
        if (!self) {
            r[12] = this[12];
            r[13] = this[13];
            r[14] = this[14];
            r[15] = this[15];
        }
        return r;
    }
}

const pointsVertexShader = () => {
    return `
    attribute vec4 p_position;
    void main() {
      gl_Position = p_position;
    }
  `;
};
const pointsFragmentShader = (r, g, b) => {
    return `
      void main(){
        gl_FragColor = vec4(${r}, ${g}, ${b}, 1.0);
      }
  `;
};

const imagePointShader_A = `
attribute vec4 a_position;
attribute vec2 a_texcoord;

uniform mat4 u_matrix;

varying vec2 v_texcoord;

void main() {
   gl_Position = u_matrix * a_position;
   v_texcoord = a_texcoord;
}`;
const imageFragmentShader_A = `precision mediump float;

varying vec2 v_texcoord;

uniform sampler2D u_texture;

void main() {
   gl_FragColor = texture2D(u_texture, v_texcoord);
}`;

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class EwContext {
    constructor(query) {
        this.gl = null;
        this.program = null;
        this.strokeStyle = '#000000';
        this.lineWidth = 1;
        this.strokeRgb = [];
        this._path = [];
        this._pathArray = [];
        this._pathStatus = 'end';
        this.init(query);
    }
    beginPath() {
        this._pathStatus = 'begin';
    }
    closePath() {
        this._pathStatus = 'end';
        this._pathArray.push(this._path);
        this._path = [];
    }
    moveTo(x, y) {
        this._path.push(new Point(x, y, true, this._target.width, this._target.height));
        this._pathStatus = 'begin';
    }
    lineTo(x, y) {
        if (this._pathStatus !== 'begin') {
            warn('Not ivalid,please use moveTo first', 2);
            return;
        }
        this._path.push(new Point(x, y, true, this._target.width, this._target.height));
    }
    init(query) {
        const { gl, dom } = createContext(query);
        this.gl = gl;
        this._target = dom;
        this.gl.viewport(0, 0, dom.width, dom.height);
    }
    clearRect() {
    }
    clear() {
        const { gl } = this;
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.clearDepth(1.0);
    }
    drawImage(...args) {
        if (args.length === 3) {
            this._drawImageA(args[0], args[1], args[2]);
        }
        if (args.length === 5) {
            this._drawImageB(args[0], args[1], args[2], args[3], args[4]);
        }
        if (args.length === 9) {
            this._drawImageC(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
        }
    }
    _loadAndCreateTexture(_img, gl) {
        return new Promise((resolve) => {
            if (typeof _img === 'string') {
                loadImage(_img, (ele) => {
                    const tx = new Texture();
                    tx.texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, tx.texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    tx.width = ele.width;
                    tx.height = ele.height;
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, ele);
                    resolve(tx);
                });
            }
        });
    }
    _drawImageA(image, dx, dy) {
        return __awaiter(this, void 0, void 0, function* () {
            this._drawImageB(image, dx, dy);
        });
    }
    _drawImageB(image, dx, dy, dWidth, dHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this._loadAndCreateTexture(image, this.gl);
            const program = createShaderProgram(this.gl, imagePointShader_A, imageFragmentShader_A);
            const positionLocation = this.gl.getAttribLocation(program, 'a_position');
            const texcoordLocation = this.gl.getAttribLocation(program, 'a_texcoord');
            const matrixLocation = this.gl.getUniformLocation(program, 'u_matrix');
            const textureLocation = this.gl.getUniformLocation(program, 'u_texture');
            const positionBuffer = initBuffers(this.gl, [
                0, 0,
                0, 1,
                1, 0,
                1, 0,
                0, 1,
                1, 1
            ]);
            const texcoordBuffer = initBuffers(this.gl, [
                0, 0,
                0, 1,
                1, 0,
                1, 0,
                0, 1,
                1, 1
            ]);
            injectAttribute2D(this.gl, positionBuffer, positionLocation);
            injectAttribute2D(this.gl, texcoordBuffer, texcoordLocation);
            let matrix = new Matrix4()
                .orthographic(0, this._target.width, this._target.height, 0, -1, 1)
                .scale(dWidth || tx.width, dHeight || tx.height, 1)
                .translate(dx / this._target.width, dy / this._target.height, 0);
            this.gl.uniformMatrix4fv(matrixLocation, false, matrix);
            this.gl.uniform1i(textureLocation, 0);
            this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
            this.gl.deleteProgram(program);
        });
    }
    _drawImageC(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
    }
    fillRect(x, y, width, height) {
    }
    stroke() {
        const renderPoints = [];
        for (let i = 0, l = this._pathArray.length; i < l; i++) {
            for (let j = 1, m = this._pathArray[i].length; j < m; j++) {
                const beginPoint = this._pathArray[i][j - 1];
                const endPoint = this._pathArray[i][j];
                renderPoints.push(beginPoint.x, beginPoint.y, 0, 1, endPoint.x, endPoint.y, 0, 1);
            }
        }
        if (this.lineWidth === 1) {
            const color = toRgb(this.strokeStyle);
            const shaderProgram = createShaderProgram(this.gl, pointsVertexShader(), pointsFragmentShader(color[0], color[1], color[2]));
            initBuffers(this.gl, renderPoints);
            const vertexPosition = this.gl.getAttribLocation(shaderProgram, 'p_position');
            this.gl.vertexAttribPointer(vertexPosition, 4, this.gl.FLOAT, false, 0, 0);
            this.gl.enableVertexAttribArray(vertexPosition);
            this.gl.drawArrays(this.gl.LINES, 0, renderPoints.length / 4);
        }
    }
    strokeRect(x, y, width, height) {
    }
}

export { EwContext, Matrix4, Point, ShaderType, Texture, Vector2, WARN_LEVEL, canvasToWebglCoordinate, createContext, createShaderProgram, imageFragmentShader_A, imagePointShader_A, initBuffers, injectAttribute2D, isWebGl2, loadImage, loadShader, offsetLine, pointsFragmentShader, pointsVertexShader, toRgb, warn };
